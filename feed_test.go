package neows

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

func TestFeed(t *testing.T) {

	// Create mock response body (generated by github co-pilot)
	mockResponseBody := []byte(`{"links": {"self": "self", "next": "next", "prev": "prev"}, "element_count": 1, "near_earth_objects": {"2021-06-01": [{"id": "id", "name": "name", "nasa_jpl_url": "nasa_jpl_url", "absolute_magnitude_h": 1, "estimated_diameter": {"kilometers": {"estimated_diameter_min": 1, "estimated_diameter_max": 1}}, "is_potentially_hazardous_asteroid": true, "close_approach_data": [{"close_approach_date": "2021-06-01", "relative_velocity": {"kilometers_per_second": "1", "kilometers_per_hour": "1"}, "miss_distance": {"kilometers": "1"}, "orbiting_body": "Earth"}]}]}}`)

	t.Run("Should use the default options if none are provided", func(t *testing.T) {
		// Create a mock server that checks if the default options are set
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defaultOpts := NewDefaultFeedOptions()

			detailed := r.URL.Query().Get("detailed")
			dDetailed := fmt.Sprintf("%t", defaultOpts.Detailed)
			if detailed != dDetailed {
				t.Errorf("expected %s, got %s", "false", detailed)
			}

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(mockResponseBody)
		}))

		feedService := &FeedService{Client: NewClient(defaultAPIKey), BaseURL: ts.URL, opts: NewDefaultFeedOptions()}
		_, err := feedService.Fetch(time.Now(), time.Now())
		if err != nil {
			t.Error(err)
		}
	})

	t.Run("Should return an error if date range is invalid", func(t *testing.T) {
		feedService := NewFeedService(NewClient(defaultAPIKey), nil)
		_, err := feedService.Fetch(time.Now(), time.Now().AddDate(0, 0, -1))
		if err == nil {
			t.Error("expected error to be returned for start date > end date, got nil")
		}

		_, err = feedService.Fetch(time.Now(), time.Now().AddDate(0, 0, 8))
		if err == nil {
			t.Error("expected error to be returned for date range > 7 days, got nil")
		}
	})

	t.Run("Should return an error if the HTTP status code is not 200", func(t *testing.T) {
		// Create a mock server that returns a 500 status code
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusInternalServerError)
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(defaultAPIKey), BaseURL: ts.URL}

		// Sends a request to the mock server
		_, err := feedService.Fetch(time.Now(), time.Now())
		if err == nil {
			t.Error("Should return an error")
		}
	})

	t.Run("Should parse the response", func(t *testing.T) {
		// Create a server that returns a mocked response
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(mockResponseBody)
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(defaultAPIKey), BaseURL: ts.URL}

		// Sends a request to the mock server
		feed, err := feedService.Fetch(time.Now(), time.Now())
		if err != nil {
			t.Error(err)
		}

		failWithParseErr := func(fieldName string) {
			t.Errorf("Should parse the %s field", fieldName)
		}

		// Check if the response is parsed correctly
		if feed.Links.Self != "self" {
			failWithParseErr("links.self")
		}
		if feed.Links.Next != "next" {
			failWithParseErr("links.next")
		}
		if feed.Links.Prev != "prev" {
			failWithParseErr("links.prev")
		}
		if feed.ElementCount != 1 {
			failWithParseErr("element_count")
		}
		if feed.NeosByDate["2021-06-01"][0].ID != "id" {
			failWithParseErr("near_earth_objects.id")
		}
		if feed.NeosByDate["2021-06-01"][0].Name != "name" {
			failWithParseErr("near_earth_objects.name")
		}
		if feed.NeosByDate["2021-06-01"][0].NasaJplURL != "nasa_jpl_url" {
			failWithParseErr("near_earth_objects.nasa_jpl_url")
		}
		if feed.NeosByDate["2021-06-01"][0].AbsoluteMagnitudeH != 1 {
			failWithParseErr("near_earth_objects.absolute_magnitude_h")
		}
		if feed.NeosByDate["2021-06-01"][0].EstimatedDiameter.Kilometers.EstimatedDiameterMin != 1 {
			failWithParseErr("near_earth_objects.estimated_diameter.kilometers.estimated_diameter_min")
		}
		if feed.NeosByDate["2021-06-01"][0].EstimatedDiameter.Kilometers.EstimatedDiameterMax != 1 {
			failWithParseErr("near_earth_objects.estimated_diameter.kilometers.estimated_diameter_max")
		}
		if feed.NeosByDate["2021-06-01"][0].IsPotentiallyHazardousAsteroid != true {
			failWithParseErr("near_earth_objects.is_potentially_hazardous_asteroid")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].CloseApproachDate != "2021-06-01" {
			failWithParseErr("near_earth_objects.close_approach_data.close_approach_date")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].RelativeVelocity.KilometersPerSecond != "1" {
			failWithParseErr("near_earth_objects.close_approach_data.relative_velocity.kilometers_per_second")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].MissDistance.Kilometers != "1" {
			failWithParseErr("near_earth_objects.close_approach_data.miss_distance.kilometers")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].OrbitingBody != "Earth" {
			failWithParseErr("near_earth_objects.close_approach_data.orbiting_body")
		}
	})

	// The following test cases makes actual call to the NASA API. They're
	// skipped by default because they can fail due to network issues or API
	// changes. To run them, remove the t.Skip() call.

	t.Run("Should get a real feed by date range", func(t *testing.T) {
		t.Skip("Skipping actual API calls")
		client := NewClient(defaultAPIKey)
		fs := NewFeedService(client, &FeedOptions{Detailed: true})		
		
		start, err := time.Parse("2006-01-02", "2021-06-01")
		if err != nil {
			t.Errorf("Error parsing start date: %s", err)
		}
		end, err := time.Parse("2006-01-02", "2021-06-07")
		if err != nil {
			t.Errorf("Error parsing end date: %s", err)
		}

		feed, err := fs.Fetch(start, end)
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if feed == nil {
			t.Errorf("Feed should not be nil")
		}
		if feed.NeosByDate == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}

		for date, neo := range feed.NeosByDate {
			fmt.Printf("Asteroids approaching in %s\n", date)
			for _, n := range neo {
				fmt.Printf("\tName: %s\n", n.Name)
				fmt.Printf("\tNASA JPL URL: %s\n", n.NasaJplURL)
				fmt.Printf("\tPotentialy hazardous: %t\n", n.IsPotentiallyHazardousAsteroid)
				fmt.Printf("\tMiss distance: %s km\n\n", n.CloseApproachData[0].MissDistance.Kilometers)
			}
			fmt.Printf("\n")
		}
	})

	t.Run("Should get today's feed", func(t *testing.T) {
		t.Skip("Skipping actual API calls")
		client := NewClient(defaultAPIKey)
		feed, err := client.Feed.Today()
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if feed == nil {
			t.Errorf("Feed should not be nil")
		}
		if feed.NeosByDate == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}

		today := time.Now().Format("2006-01-02")
		for date := range feed.NeosByDate {
			if date != today {
				t.Errorf("Expected date to be %s, got %s", today, date)
			}
		}
	})

	t.Run("Shoud get tomorrow's and yesterday's feeds, from today's feed", func(t *testing.T) {
		t.Skip("Skipping actual API calls")
		client := NewClient(defaultAPIKey)
		feed, err := client.Feed.Today()
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if feed == nil {
			t.Errorf("Feed should not be nil")
		}
		if feed.NeosByDate == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}

		tFeed, err := client.Feed.Next(feed)
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if tFeed == nil {
			t.Errorf("Feed should not be nil")
		}
		if tFeed.NeosByDate == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}

		tomorrow := time.Now().AddDate(0, 0, 1).Format("2006-01-02")
		for date := range tFeed.NeosByDate {
			if date != tomorrow {
				t.Errorf("Expected date to be %s, got %s", tomorrow, date)
			}
		}

		pFeed, err := client.Feed.Prev(feed)
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if pFeed == nil {
			t.Errorf("Feed should not be nil")
		}
		if pFeed.NeosByDate == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}
		yesterday := time.Now().AddDate(0, 0, -1).Format("2006-01-02")
		for date := range pFeed.NeosByDate {
			if date != yesterday {
				t.Errorf("Expected date to be %s, got %s", yesterday, date)
			}
		}
	})
}
