package neows

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

func TestFeed(t *testing.T) {

	// Create mock response body (generated by github co-pilot)
	mockResponseBody := []byte(`{"links": {"self": "self", "next": "next", "previous": "prev"}, "element_count": 1, "near_earth_objects": {"2021-06-01": [{"id": "id", "name": "name", "nasa_jpl_url": "nasa_jpl_url", "absolute_magnitude_h": 1, "estimated_diameter": {"kilometers": {"estimated_diameter_min": 1, "estimated_diameter_max": 1}}, "is_potentially_hazardous_asteroid": true, "close_approach_data": [{"close_approach_date": "2021-06-01", "relative_velocity": {"kilometers_per_second": "1", "kilometers_per_hour": "1"}, "miss_distance": {"kilometers": "1"}, "orbiting_body": "Earth"}]}]}}`)

	t.Run("Should use the default options if none are provided", func(t *testing.T) {
		// Create a mock server that checks if the default options are set
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defaultOpts := NewFeedOptions()
			
			startDate := r.URL.Query().Get("start_date")
			dStartDate := defaultOpts.StartDate.Format("2006-01-02")
			if startDate != dStartDate {
				t.Errorf("expected %s, got %s", time.Now().Format("2006-01-02"), startDate)
			}
			
			endDate := r.URL.Query().Get("end_date")
			dEndDate := defaultOpts.EndDate.Format("2006-01-02")
			if endDate != dEndDate {
				t.Errorf("expected %s, got %s", time.Now().AddDate(0, 0, 7).Format("2006-01-02"), endDate)
			}
			
			detailed := r.URL.Query().Get("detailed")
			dDetailed := fmt.Sprintf("%t", defaultOpts.Detailed)
			if detailed != dDetailed {
				t.Errorf("expected %s, got %s", "false", detailed)
			}

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(mockResponseBody)
		}))

		feedService := &FeedService{Client: NewClient(defaultAPIKey), BaseURL: ts.URL}
		_, err := feedService.Fetch(nil)
		if err != nil {
			t.Error(err)
		}
	})

	t.Run("Should return an error if the response is not 200", func(t *testing.T) {
		// Create a mock server that returns a 500 status code
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusInternalServerError)
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(defaultAPIKey), BaseURL: ts.URL}

		// Sends a request to the mock server
		_, err := feedService.Fetch(nil)
		if err == nil {
			t.Error("Should return an error")
		}
	})

	t.Run("Should parse the response", func(t *testing.T) {
		// Create a server that returns a mocked response
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(mockResponseBody)
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(defaultAPIKey), BaseURL: ts.URL}

		// Sends a request to the mock server
		feed, err := feedService.Fetch(nil)
		if err != nil {
			t.Error(err)
		}

		failWithParseErr := func(fieldName string) {
			t.Errorf("Should parse the %s field", fieldName)
		}

		// Check if the response is parsed correctly
		if feed.Links.Self != "self" {
			failWithParseErr("links.self")
		}
		if feed.Links.Next != "next" {
			failWithParseErr("links.next")
		}
		if feed.Links.Prev != "prev" {
			failWithParseErr("links.previous")
		}
		if feed.ElementCount != 1 {
			failWithParseErr("element_count")
		}
		if feed.NeosByDate["2021-06-01"][0].ID != "id" {
			failWithParseErr("near_earth_objects.id")
		}
		if feed.NeosByDate["2021-06-01"][0].Name != "name" {
			failWithParseErr("near_earth_objects.name")
		}
		if feed.NeosByDate["2021-06-01"][0].NasaJplURL != "nasa_jpl_url" {
			failWithParseErr("near_earth_objects.nasa_jpl_url")
		}
		if feed.NeosByDate["2021-06-01"][0].AbsoluteMagnitudeH != 1 {
			failWithParseErr("near_earth_objects.absolute_magnitude_h")
		}
		if feed.NeosByDate["2021-06-01"][0].EstimatedDiameter.Kilometers.EstimatedDiameterMin != 1 {
			failWithParseErr("near_earth_objects.estimated_diameter.kilometers.estimated_diameter_min")
		}
		if feed.NeosByDate["2021-06-01"][0].EstimatedDiameter.Kilometers.EstimatedDiameterMax != 1 {
			failWithParseErr("near_earth_objects.estimated_diameter.kilometers.estimated_diameter_max")
		}
		if feed.NeosByDate["2021-06-01"][0].IsPotentiallyHazardousAsteroid != true {
			failWithParseErr("near_earth_objects.is_potentially_hazardous_asteroid")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].CloseApproachDate != "2021-06-01" {
			failWithParseErr("near_earth_objects.close_approach_data.close_approach_date")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].RelativeVelocity.KilometersPerSecond != "1" {
			failWithParseErr("near_earth_objects.close_approach_data.relative_velocity.kilometers_per_second")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].MissDistance.Kilometers != "1" {
			failWithParseErr("near_earth_objects.close_approach_data.miss_distance.kilometers")
		}
		if feed.NeosByDate["2021-06-01"][0].CloseApproachData[0].OrbitingBody != "Earth" {
			failWithParseErr("near_earth_objects.close_approach_data.orbiting_body")
		}
	})

	// The following test case makes an actual call to the NASA API. It is skipped by default.
	t.Run("Should get a real feed by date range", func(t *testing.T) {
		t.Skip("Skipping actual API calls")
		client := NewClient(defaultAPIKey)
		startDate, err := time.Parse("2006-01-02", "2021-06-01")
		if err != nil {
			t.Errorf("Error parsing start date: %s", err)
		}
		endDate, err := time.Parse("2006-01-02", "2021-06-02")
		if err != nil {
			t.Errorf("Error parsing end date: %s", err)
		}

		opts := &FeedOptions{
			StartDate: startDate,
			EndDate:   endDate,
			Detailed: true,
		}
		feed, err := client.Feed.Fetch(opts)
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if feed == nil {
			t.Errorf("Feed should not be nil")
		}
		if feed.NeosByDate == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}

		for date, neo := range feed.NeosByDate {
			fmt.Printf("Asteroids approaching in %s\n", date)
			for _, n := range neo {
				fmt.Printf("\tName: %s\n", n.Name)
				fmt.Printf("\tNASA JPL URL: %s\n", n.NasaJplURL)
				fmt.Printf("\tPotentialy hazardous: %t\n", n.IsPotentiallyHazardousAsteroid)
				fmt.Printf("\tMiss distance: %s km\n\n", n.CloseApproachData[0].MissDistance.Kilometers)
			}
			fmt.Printf("\n")
		}
	})

}
