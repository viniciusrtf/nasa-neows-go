package neows

import (
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

func TestFeed(t *testing.T) {

	// Create mock response body (generated by github co-pilot)
	mockResponseBody := []byte(`{"links": {"self": "self", "next": "next", "previous": "prev"}, "element_count": 1, "near_earth_objects": {"2021-06-01": [{"id": "id", "name": "name", "nasa_jpl_url": "nasa_jpl_url", "absolute_magnitude_h": 1, "estimated_diameter": {"kilometers": {"estimated_diameter_min": 1, "estimated_diameter_max": 1}}, "is_potentially_hazardous_asteroid": true, "close_approach_data": [{"close_approach_date": "2021-06-01", "relative_velocity": {"kilometers_per_second": "1", "kilometers_per_hour": "1"}, "miss_distance": {"kilometers": "1"}, "orbiting_body": "Earth"}]}]}}`)

	t.Run("Should append start_date and end_date to request", func(t *testing.T) {
		// Create a mock server that checks if start_date and end_date are set
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			startDate := r.URL.Query().Get("start_date")
			endDate := r.URL.Query().Get("end_date")
			if startDate == "" || endDate == "" {
				t.Error("start_date and end_date should be set")
			}
			_, err := w.Write(mockResponseBody)
			if err != nil {
				t.Error(err)
			}
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(nil), BaseURL: ts.URL}

		// Sends a request to the mock server
		_, err := feedService.Fetch(time.Now(), time.Now().AddDate(0, 0, 7))
		if err != nil {
			t.Error(err)
		}
	})

	t.Run("Should return an error if the response is not 200", func(t *testing.T) {
		// Create a mock server that returns a 500 status code
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusInternalServerError)
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(nil), BaseURL: ts.URL}

		// Sends a request to the mock server
		_, err := feedService.Fetch(time.Now(), time.Now().AddDate(0, 0, 7))
		if err == nil {
			t.Error("Should return an error")
		}
	})

	t.Run("Should parse the response", func(t *testing.T) {
		// Create a server that returns a mocked response
		ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(mockResponseBody) // generated by github copilot
		}))

		// Create a mock feed service with the mock server as the base URL
		feedService := &FeedService{Client: NewClient(nil), BaseURL: ts.URL}

		// Sends a request to the mock server
		feed, err := feedService.Fetch(time.Now(), time.Now().AddDate(0, 0, 7))
		if err != nil {
			t.Error(err)
		}

		failWithParseErr := func(fieldName string) {
			t.Errorf("Should parse the %s field", fieldName)
		}

		// Check if the response is parsed correctly
		if feed.Links.Self != "self" {
			failWithParseErr("links.self")
		}
		if feed.Links.Next != "next" {
			failWithParseErr("links.next")
		}
		if feed.Links.Prev != "prev" {
			failWithParseErr("links.previous")
		}
		if feed.ElementCount != 1 {
			failWithParseErr("element_count")
		}
		if feed.NearEarthObjects["2021-06-01"][0].ID != "id" {
			failWithParseErr("near_earth_objects.id")
		}
		if feed.NearEarthObjects["2021-06-01"][0].Name != "name" {
			failWithParseErr("near_earth_objects.name")
		}
		if feed.NearEarthObjects["2021-06-01"][0].NasaJplURL != "nasa_jpl_url" {
			failWithParseErr("near_earth_objects.nasa_jpl_url")
		}
		if feed.NearEarthObjects["2021-06-01"][0].AbsoluteMagnitudeH != 1 {
			failWithParseErr("near_earth_objects.absolute_magnitude_h")
		}
		if feed.NearEarthObjects["2021-06-01"][0].EstimatedDiameter.Kilometers.EstimatedDiameterMin != 1 {
			failWithParseErr("near_earth_objects.estimated_diameter.kilometers.estimated_diameter_min")
		}
		if feed.NearEarthObjects["2021-06-01"][0].EstimatedDiameter.Kilometers.EstimatedDiameterMax != 1 {
			failWithParseErr("near_earth_objects.estimated_diameter.kilometers.estimated_diameter_max")
		}
		if feed.NearEarthObjects["2021-06-01"][0].IsPotentiallyHazardousAsteroid != true {
			failWithParseErr("near_earth_objects.is_potentially_hazardous_asteroid")
		}
		if feed.NearEarthObjects["2021-06-01"][0].CloseApproachData[0].CloseApproachDate != "2021-06-01" {
			failWithParseErr("near_earth_objects.close_approach_data.close_approach_date")
		}
		if feed.NearEarthObjects["2021-06-01"][0].CloseApproachData[0].RelativeVelocity.KilometersPerSecond != "1" {
			failWithParseErr("near_earth_objects.close_approach_data.relative_velocity.kilometers_per_second")
		}
		if feed.NearEarthObjects["2021-06-01"][0].CloseApproachData[0].MissDistance.Kilometers != "1" {
			failWithParseErr("near_earth_objects.close_approach_data.miss_distance.kilometers")
		}
		if feed.NearEarthObjects["2021-06-01"][0].CloseApproachData[0].OrbitingBody != "Earth" {
			failWithParseErr("near_earth_objects.close_approach_data.orbiting_body")
		}
	})

	// The following test case makes an actual call to the NASA API. It is skipped by default.
	t.Run("TestGetFeedByDateRange", func(t *testing.T) {
		t.Skip("Skipping actual API call")
		client := NewClient(nil)
		startDate, err := time.Parse("2006-01-02", "2021-06-01")
		if err != nil {
			t.Errorf("Error parsing start date: %s", err)
		}
		endDate, err := time.Parse("2006-01-02", "2021-06-02")
		if err != nil {
			t.Errorf("Error parsing end date: %s", err)
		}
		feed, err := client.Feed.Fetch(startDate, endDate)
		if err != nil {
			t.Errorf("Error fetching feed: %s", err)
		}
		if feed == nil {
			t.Errorf("Feed should not be nil")
		}
		if feed.NearEarthObjects == nil {
			t.Errorf("NearEarthObjects should not be nil")
		}
	})

}
